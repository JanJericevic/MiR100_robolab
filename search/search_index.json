{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MiR100 Robolab documentation In this documentation you will find instructions for working with the MiR100 robot. This project is not affiliated with Mobile Industrial Robots. Tested on MiR100 robot software version 2.13.3.2 Acknowledgement Thank you to the DFKI team for developing and maintaining the ROS mir_robot package.","title":"Intro"},{"location":"#mir100-robolab-documentation","text":"In this documentation you will find instructions for working with the MiR100 robot. This project is not affiliated with Mobile Industrial Robots.","title":"MiR100 Robolab documentation"},{"location":"#tested-on","text":"MiR100 robot software version 2.13.3.2","title":"Tested on"},{"location":"#acknowledgement","text":"Thank you to the DFKI team for developing and maintaining the ROS mir_robot package.","title":"Acknowledgement"},{"location":"connection/","text":"Connect to the robot There are two possible ways to connect to the robot: using the MiR web interface using ROS Connect to the MiR web interface connect to the MiR_R**** hotspot open mir.com (default IP = 192.168.12.20) use your credentials to log in to the web interface Connect to the robot with ROS There are two ways of using ROS to connect to the MiR100 robot: connect to its internal roscore running on the MiR100 computer connect using mir_driver . This method runs roscore on the host computer, connecting to the MiR100 internal roscore over ROS Bridge . Internal roscore You have to be connected to the robot hotspot (MiR_R****). Set the address of the master to the address of MiR100 internal roscore and test the connection. # this needs to be done in every terminal export ROS_MASTER_URI=http://192.168.12.20:11311 export ROS_HOSTNAME=<your IP: 192.168.12.**> # test the connection # test subscriber $ rostopic list $ rostopic echo /odom # test publisher $ rostopic pub -r 50 /cmd_vel geometry_msgs/TwistStamped \"header: seq: 0 stamp: secs: 0 nsecs: 0 frame_id: '' twist: linear: x: 0.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 0.2\" Using mir_driver If connected to the MiR_R**** hotspot: # launch mir_driver $ roslaunch mir_driver mir.launch # test the connection # test subscriber $ rostopic echo /amcl_pose # test publisher $ rostopic pub -r 50 /cmd_vel geometry_msgs/Twist \"linear: x: 0.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 0.2\" If connected to the same outside network as the robot: # launch mir_driver and set the robot IP $ roslaunch mir_driver mir.launch mir_hostname:=<robot-IP> # test the connection the same way as the hotspot connection NOTE: when using mir_driver to connect to the robot we send geometry_msgs/Twist type messages instead of geometry_msgs/TwistStamped to the /cmd_vel topic. That is because the mir_driver package expects messages of type geometry_msgs/Twist on the /cmd_vel topic and converts them to geometry_msgs/TwistStamped messages before sending the commands to the robot. Connect the robot to a WIFI network You can connect the robot to an outside network: turn on the robot and connect to its hotspot go to System -> Settings -> WiFi select \"Add connection\" select the network and fill in required information when you're finished select \"Add connection\" robot IP is displayed under the network connection name. You can use this IP to access the web interface or when using mir_driver","title":"Connect to the robot"},{"location":"connection/#connect-to-the-robot","text":"There are two possible ways to connect to the robot: using the MiR web interface using ROS","title":"Connect to the robot"},{"location":"connection/#connect-to-the-mir-web-interface","text":"connect to the MiR_R**** hotspot open mir.com (default IP = 192.168.12.20) use your credentials to log in to the web interface","title":"Connect to the MiR web interface"},{"location":"connection/#connect-to-the-robot-with-ros","text":"There are two ways of using ROS to connect to the MiR100 robot: connect to its internal roscore running on the MiR100 computer connect using mir_driver . This method runs roscore on the host computer, connecting to the MiR100 internal roscore over ROS Bridge .","title":"Connect to the robot with ROS"},{"location":"connection/#internal-roscore","text":"You have to be connected to the robot hotspot (MiR_R****). Set the address of the master to the address of MiR100 internal roscore and test the connection. # this needs to be done in every terminal export ROS_MASTER_URI=http://192.168.12.20:11311 export ROS_HOSTNAME=<your IP: 192.168.12.**> # test the connection # test subscriber $ rostopic list $ rostopic echo /odom # test publisher $ rostopic pub -r 50 /cmd_vel geometry_msgs/TwistStamped \"header: seq: 0 stamp: secs: 0 nsecs: 0 frame_id: '' twist: linear: x: 0.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 0.2\"","title":"Internal roscore"},{"location":"connection/#using-mir_driver","text":"If connected to the MiR_R**** hotspot: # launch mir_driver $ roslaunch mir_driver mir.launch # test the connection # test subscriber $ rostopic echo /amcl_pose # test publisher $ rostopic pub -r 50 /cmd_vel geometry_msgs/Twist \"linear: x: 0.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 0.2\" If connected to the same outside network as the robot: # launch mir_driver and set the robot IP $ roslaunch mir_driver mir.launch mir_hostname:=<robot-IP> # test the connection the same way as the hotspot connection NOTE: when using mir_driver to connect to the robot we send geometry_msgs/Twist type messages instead of geometry_msgs/TwistStamped to the /cmd_vel topic. That is because the mir_driver package expects messages of type geometry_msgs/Twist on the /cmd_vel topic and converts them to geometry_msgs/TwistStamped messages before sending the commands to the robot.","title":"Using mir_driver"},{"location":"connection/#connect-the-robot-to-a-wifi-network","text":"You can connect the robot to an outside network: turn on the robot and connect to its hotspot go to System -> Settings -> WiFi select \"Add connection\" select the network and fill in required information when you're finished select \"Add connection\" robot IP is displayed under the network connection name. You can use this IP to access the web interface or when using mir_driver","title":"Connect the robot to a WIFI network"},{"location":"control/","text":"Controlling the robot NOTE: everytime before using the robot synchronize system time as best you can. In the MiR interface go to: \"System\" -> \"Settings\" -> \"Date & Time\". For an advanced setup see this solution . You can control the robot over the MiR web interface or using ROS. Web interface ROS","title":"Controlling the robot"},{"location":"control/#controlling-the-robot","text":"NOTE: everytime before using the robot synchronize system time as best you can. In the MiR interface go to: \"System\" -> \"Settings\" -> \"Date & Time\". For an advanced setup see this solution . You can control the robot over the MiR web interface or using ROS. Web interface ROS","title":"Controlling the robot"},{"location":"control_ros/","text":"ROS control Using a joystick To control the robot with a joystick use the mir_joy_teleop package. As with connecting to the robot , there is a slight difference between sending the joystick commands directly to the robots internal roscore or with the mir_driver . Internal roscore # launch a joy_node and a teleop node # default input device is js1 $ roslaunch mir_joy_teleop joy_teleop.launch # specify input device - e.g. js2 $ roslaunch mir_joy_teleop joy_teleop.launch device:=js2 Using mir_driver # launch a joy_node and a teleop node # we specify the use of an external roscore (default value is 'internal') # default input device is js1 $ roslaunch mir_joy_teleop joy_teleop.launch roscore:=external # specify input device - e.g. js2 $ roslaunch mir_joy_teleop joy_teleop.launch device:=js2 roscore:=external","title":"ROS"},{"location":"control_ros/#ros-control","text":"","title":"ROS control"},{"location":"control_ros/#using-a-joystick","text":"To control the robot with a joystick use the mir_joy_teleop package. As with connecting to the robot , there is a slight difference between sending the joystick commands directly to the robots internal roscore or with the mir_driver .","title":"Using a joystick"},{"location":"control_ros/#internal-roscore","text":"# launch a joy_node and a teleop node # default input device is js1 $ roslaunch mir_joy_teleop joy_teleop.launch # specify input device - e.g. js2 $ roslaunch mir_joy_teleop joy_teleop.launch device:=js2","title":"Internal roscore"},{"location":"control_ros/#using-mir_driver","text":"# launch a joy_node and a teleop node # we specify the use of an external roscore (default value is 'internal') # default input device is js1 $ roslaunch mir_joy_teleop joy_teleop.launch roscore:=external # specify input device - e.g. js2 $ roslaunch mir_joy_teleop joy_teleop.launch device:=js2 roscore:=external","title":"Using mir_driver"},{"location":"control_web/","text":"Web interface control Interface overview Let this serve as a brief overview of the MiR web interface. For detailed instructions see the full interface documentation . Top bar The top bar shows information on the current state of the robot. You can start/pause the robot, check robot status, select you language, select your user, check the robot battery percentage or manually control the robot with the joystick. Robot speed for manual control is fixed when using the joystick from the top bar. Navigation To get to a specific subsection of the interface select an item in the primary menu and then in the relevant sub-menu. Dashboards Dashboards are the main way you interact with the robot over the web interface. You can create your own dashboard that displays only relevant information for your use case. Select Dashboards to open the list of dashboards, and select the Create dashboard button to open the dashboard designer. Alternatively, you can select an existing dashboard from the list. TODO: dashboard description TODO: dashboard picture Map creation Missions A mission is a predefined series of actions that the robot can be set to perform. Manual control TODO: test if The joystick for driving the robot in Manual mode cannot be operated on Windows-based devices. Goal","title":"Web interface"},{"location":"control_web/#web-interface-control","text":"","title":"Web interface control"},{"location":"control_web/#interface-overview","text":"Let this serve as a brief overview of the MiR web interface. For detailed instructions see the full interface documentation .","title":"Interface overview"},{"location":"control_web/#top-bar","text":"The top bar shows information on the current state of the robot. You can start/pause the robot, check robot status, select you language, select your user, check the robot battery percentage or manually control the robot with the joystick. Robot speed for manual control is fixed when using the joystick from the top bar.","title":"Top bar"},{"location":"control_web/#navigation","text":"To get to a specific subsection of the interface select an item in the primary menu and then in the relevant sub-menu.","title":"Navigation"},{"location":"control_web/#dashboards","text":"Dashboards are the main way you interact with the robot over the web interface. You can create your own dashboard that displays only relevant information for your use case. Select Dashboards to open the list of dashboards, and select the Create dashboard button to open the dashboard designer. Alternatively, you can select an existing dashboard from the list. TODO: dashboard description TODO: dashboard picture","title":"Dashboards"},{"location":"control_web/#map-creation","text":"","title":"Map creation"},{"location":"control_web/#missions","text":"A mission is a predefined series of actions that the robot can be set to perform.","title":"Missions"},{"location":"control_web/#manual-control","text":"TODO: test if The joystick for driving the robot in Manual mode cannot be operated on Windows-based devices.","title":"Manual control"},{"location":"control_web/#goal","text":"","title":"Goal"},{"location":"docker/","text":"Working with Docker Docker containers allow you flexibility in your setup: reproducibility of environments/projects no need for OS wide ROS install possibility of switching between ROS versions Install Docker engine Full install instructions are available at Dockers official website . Make sure old versions od Docker engine are uninstalled . # update the apt package index and install packages to allow apt to use a repository over HTTPS: $ sudo apt-get update $ sudo apt-get install ca-certificates curl gnupg # add Docker\u2019s official GPG key $ sudo install -m 0755 -d /etc/apt/keyrings $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg $ sudo chmod a+r /etc/apt/keyrings/docker.gpg # set up the repository $ echo \\ \"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ \"$(. /etc/os-release && echo \"$VERSION_CODENAME\")\" stable\" | \\ sudo tee /etc/apt/sources.list.d/docker.list > /dev/null # Update the apt package index $ sudo apt-get update # install the latest version $ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin # verify the installation $ sudo docker run hello-world Optional post installation steps All optional installation steps are available at Dockers official website . Useful post installation step is to manage Docker as a non sudo user. This allow the omission of sudo in front of docker commands. When allowing this make sure to be aware of how this impacts security of your system . # create the docker group # on some Linux distributions, the system automatically creates this group when installing Docker Engine using a package manager $ sudo groupadd docker # add your user to the docker group $ sudo usermod -aG docker $USER # log out and log back in so that your group membership is re-evaluated # or un the following command to activate the changes to groups $ newgrp docker # verify that you can run docker commands without sudo $ docker run hello-world Building the image If all you want is to connect to the MiR100 roscore for monitoring all you need is a ROS Docker image. However, we will build a custom ROS Docker image complete with the same ROS packages as with the OS wide ROS install, so you have a choice of running the project locally or using Docker containers. # download the desired packages to the \"src\" of your \"workspace\" $ mkdir -p ~/MiR100/ws/src $ cd ~/MiR100/ws/src $ git clone -b noetic https://github.com/DFKI-NI/mir_robot.git $ git clone -b main https://github.com/JanJericevic/MiR100_robolab.git # move the Dockerfile in MiR100_robolab folder to the src folder $ cd ~/MiR100/ws/src/MiR100_robolab $ mv ~/MiR100/ws/src/MiR100_robolab/Dockerfile ~/MiR100/ws/src # build the Docker image $ cd ~/MiR100/ws/src $ docker build -t <image-name> --build-arg MYUID=$(id -u) --build-arg MYGID=$(id -g) --build-arg MYUSER=$(id -nu) --build-arg MYGROUP=$(id -ng) . # list your built Docker images # verify that your <image-name> is among the listed images $ docker images NOTE: if you're on a machine with no OS wide ROS install and don't have a catkin ws the steps remain the same. Move the Dockerfile to the root directory of your packages, then build the Docker image in that root directory. The build commands remain the same. To avoid permissions issues with shared files between the host computer and the image container, we create a user with sudo permissions inside the image (this is especially relevant during development ). User profile can be changed when building the image (the build-arg listed above) and inside the Dockerfile . The current profile settings are: username : same as the host username that built the image password : same as the username The Dockerfile creates a catkin workspace at /home/<your-user>/ws inside the image. The workspace is also set as the work directory of the image so it will be the starting point of every new container. Depending on your use case you will use the Docker image during development (you plan to regularly modify your codebase) or you will only use it for deployment. For deployment you only need to copy your files once, which is what we have done until now. For a development setup see the volume mounting section. TODO - dockerfile names - dockerignore - entrypoints - convenience scripts - useful tags Running the image You can open an interactive bash shell with: docker run -it <image-name> bash This is ok for simple tasks however more advanced tasks require additional commands. Below are explanations for specific commands. However, since the commands can get complicated, we recommend the use of convenience scripts for repetitive cases. Create your own or use one of ours . Networking There are many options for the network settings of a container that you can read about here . Depending on your application you may want to use another option, in our case we choose to use the host's network inside the container. Among other things, this allows containers to talk to each other (e.g. one container is running the roscore , the other subscribes to a topic). docker run -it --net=host <image-name> bash GUI applications ROS workflow is full of visual tools, which means that we need graphics capabilities from inside the container. ROS wiki mentions a few possible methods. Here we take the simple but unsecure method using X server. We expose our xhost so that the container can render to the correct display by reading and writing though the X11 unix socket. docker run -it --net=host \\ --env=\"DISPLAY\" \\ --env=\"QT_X11_NO_MITSHM=1\" \\ --volume=\"/tmp/.X11-unix:/tmp/.X11-unix:rw\" \\ --device /dev/dri \\ <image-name> \\ bash Before you start the container, you have to change access permissions to the X server. The easiest is to grant access to everyone, or you can specify a specific user. # disables access control $ xhost + # grants access to specific user $ xhost +local:<user-name> # or $ xhost +SI:local:<user-name> Changes to the X server access only persist until the next logout/login, but it is best practice to enable back the access control once you're finished working with the container. # enables access control $ xhost - NVIDIA Users of NVIDIA GPUs can download the NVIDIA Container Toolkit , which allows them to build GPU accelerated containers or in some cases solve display issues if the above mentioned setup is not working. The \"Graphics inside Docker Containers\" paragraph of this ROS&Docker guide describes working with such images. # example of a docker run command for NVIDIA GPU enabled container $ docker run -it --net=host --gpus all \\ --env=\"NVIDIA_DRIVER_CAPABILITIES=all\" \\ --env=\"DISPLAY\" \\ --env=\"QT_X11_NO_MITSHM=1\" \\ --volume=\"/tmp/.X11-unix:/tmp/.X11-unix:rw\" \\ --device /dev/dri \\ <image-name> \\ bash Volume mounting NOTE: mounted files are available only at runtime. Any files needed for building the image should be copied before then. For development we want persistent files that are shared between the host machine and the containers, files that can be changed both from the host side and from inside the container, in a setup which does not require us to rebuild the image every time we modify our code. We achieve this using volumes . To achieve the necessary permissions we create a sudo user inside the image (see \" Building the image \" section). Example development setup for a host with the OS wide ROS install: $ docker run -it \\ --volume=\"/home/<host-user>/ws\":\"/home/<container-user>/ws\":rw \\ <image-name> \\ bash We mount our host side workspace /home/<host-user>/ws to the container side workspace /home/<container-user>/ws in read-write mode. This means that the two workspaces are connected. Any change that we make in either of the two will affect both. It is best practice to build the workspace every time you start a new container and of course, every time you make a change to the code base. Example development setup for a host without the OS wide ROS install: $ docker run -it \\ --volume=\"/home/<host-user>/ws/src\":\"/home/<container-user>/ws/src\":rw \\ <image-name> \\ bash Here we only mount the src folder of our host side workspace /home/<host-user>/ws/src to the src folder of our container side workspace /home/<container-user>/ws/src in read-write mode. This means that the two folders are connected. Any change that we make in either of the two will affect both. However, since only the src folders of the workspaces are connected, the workspace still needs to be built inside the container with catkin_make . It is best practice to build the workspace every time you start a new container and of course, every time you make a change to the code base. TODO: entrypoints, can you mount whole workspace? Input devices Always plug in your input devices before running the Docker container. To use input devices like joysticks inside the Docker container we have to mount them when starting the container. docker run -it \\ --device /dev/input \\ <image-name> \\ bash The above example mounts the whole input directory but you can also specify specific devices. Here we mount joystick 0. docker run -it \\ --device /dev/input/js0 \\ <image-name> \\ bash OPTIONAL: Some input devices require you to change their permissions so that they become accessible to your application (e.g. \"Configuring the Joystick\" section of this ROS tutorial). To avoid repetative changing of permissions every time you plug them in, you can create a udev rule. # with the desired input device unplugged # list the input devices on your host $ ls /dev/input by-id event0 event10 event3 event5 event7 event9 mouse0 mouse2 by-path event1 event11 event2 event4 event6 event8 mice mouse1 # plug in the desired input device # again list the input devices to see your device name $ ls /dev/input by-id event1 event20 event5 event8 mice mouse2 by-path event10 event19 event3 event6 event9 mouse0 event0 event11 event2 event4 event7 js0 mouse1 Using the above method, we find that our device name is js0 . Now we create a udev rule. Add a file /etc/udev/rules.d/99-userdev-input.rules with: KERNEL==\"js0\", SUBSYSTEM==\"input\", ACTION==\"add\", RUN+=\"/usr/bin/setfacl -m o:rw $env{DEVNAME}\" This udev rule uses ACL to set the read-write permissions of the input device js0 for the others group. You can modify the rule using ACL commands.","title":"Working with Docker"},{"location":"docker/#working-with-docker","text":"Docker containers allow you flexibility in your setup: reproducibility of environments/projects no need for OS wide ROS install possibility of switching between ROS versions","title":"Working with Docker"},{"location":"docker/#install-docker-engine","text":"Full install instructions are available at Dockers official website . Make sure old versions od Docker engine are uninstalled . # update the apt package index and install packages to allow apt to use a repository over HTTPS: $ sudo apt-get update $ sudo apt-get install ca-certificates curl gnupg # add Docker\u2019s official GPG key $ sudo install -m 0755 -d /etc/apt/keyrings $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg $ sudo chmod a+r /etc/apt/keyrings/docker.gpg # set up the repository $ echo \\ \"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ \"$(. /etc/os-release && echo \"$VERSION_CODENAME\")\" stable\" | \\ sudo tee /etc/apt/sources.list.d/docker.list > /dev/null # Update the apt package index $ sudo apt-get update # install the latest version $ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin # verify the installation $ sudo docker run hello-world","title":"Install Docker engine"},{"location":"docker/#optional-post-installation-steps","text":"All optional installation steps are available at Dockers official website . Useful post installation step is to manage Docker as a non sudo user. This allow the omission of sudo in front of docker commands. When allowing this make sure to be aware of how this impacts security of your system . # create the docker group # on some Linux distributions, the system automatically creates this group when installing Docker Engine using a package manager $ sudo groupadd docker # add your user to the docker group $ sudo usermod -aG docker $USER # log out and log back in so that your group membership is re-evaluated # or un the following command to activate the changes to groups $ newgrp docker # verify that you can run docker commands without sudo $ docker run hello-world","title":"Optional post installation steps"},{"location":"docker/#building-the-image","text":"If all you want is to connect to the MiR100 roscore for monitoring all you need is a ROS Docker image. However, we will build a custom ROS Docker image complete with the same ROS packages as with the OS wide ROS install, so you have a choice of running the project locally or using Docker containers. # download the desired packages to the \"src\" of your \"workspace\" $ mkdir -p ~/MiR100/ws/src $ cd ~/MiR100/ws/src $ git clone -b noetic https://github.com/DFKI-NI/mir_robot.git $ git clone -b main https://github.com/JanJericevic/MiR100_robolab.git # move the Dockerfile in MiR100_robolab folder to the src folder $ cd ~/MiR100/ws/src/MiR100_robolab $ mv ~/MiR100/ws/src/MiR100_robolab/Dockerfile ~/MiR100/ws/src # build the Docker image $ cd ~/MiR100/ws/src $ docker build -t <image-name> --build-arg MYUID=$(id -u) --build-arg MYGID=$(id -g) --build-arg MYUSER=$(id -nu) --build-arg MYGROUP=$(id -ng) . # list your built Docker images # verify that your <image-name> is among the listed images $ docker images NOTE: if you're on a machine with no OS wide ROS install and don't have a catkin ws the steps remain the same. Move the Dockerfile to the root directory of your packages, then build the Docker image in that root directory. The build commands remain the same. To avoid permissions issues with shared files between the host computer and the image container, we create a user with sudo permissions inside the image (this is especially relevant during development ). User profile can be changed when building the image (the build-arg listed above) and inside the Dockerfile . The current profile settings are: username : same as the host username that built the image password : same as the username The Dockerfile creates a catkin workspace at /home/<your-user>/ws inside the image. The workspace is also set as the work directory of the image so it will be the starting point of every new container. Depending on your use case you will use the Docker image during development (you plan to regularly modify your codebase) or you will only use it for deployment. For deployment you only need to copy your files once, which is what we have done until now. For a development setup see the volume mounting section. TODO - dockerfile names - dockerignore - entrypoints - convenience scripts - useful tags","title":"Building the image"},{"location":"docker/#running-the-image","text":"You can open an interactive bash shell with: docker run -it <image-name> bash This is ok for simple tasks however more advanced tasks require additional commands. Below are explanations for specific commands. However, since the commands can get complicated, we recommend the use of convenience scripts for repetitive cases. Create your own or use one of ours .","title":"Running the image"},{"location":"docker/#networking","text":"There are many options for the network settings of a container that you can read about here . Depending on your application you may want to use another option, in our case we choose to use the host's network inside the container. Among other things, this allows containers to talk to each other (e.g. one container is running the roscore , the other subscribes to a topic). docker run -it --net=host <image-name> bash","title":"Networking"},{"location":"docker/#gui-applications","text":"ROS workflow is full of visual tools, which means that we need graphics capabilities from inside the container. ROS wiki mentions a few possible methods. Here we take the simple but unsecure method using X server. We expose our xhost so that the container can render to the correct display by reading and writing though the X11 unix socket. docker run -it --net=host \\ --env=\"DISPLAY\" \\ --env=\"QT_X11_NO_MITSHM=1\" \\ --volume=\"/tmp/.X11-unix:/tmp/.X11-unix:rw\" \\ --device /dev/dri \\ <image-name> \\ bash Before you start the container, you have to change access permissions to the X server. The easiest is to grant access to everyone, or you can specify a specific user. # disables access control $ xhost + # grants access to specific user $ xhost +local:<user-name> # or $ xhost +SI:local:<user-name> Changes to the X server access only persist until the next logout/login, but it is best practice to enable back the access control once you're finished working with the container. # enables access control $ xhost -","title":"GUI applications"},{"location":"docker/#nvidia","text":"Users of NVIDIA GPUs can download the NVIDIA Container Toolkit , which allows them to build GPU accelerated containers or in some cases solve display issues if the above mentioned setup is not working. The \"Graphics inside Docker Containers\" paragraph of this ROS&Docker guide describes working with such images. # example of a docker run command for NVIDIA GPU enabled container $ docker run -it --net=host --gpus all \\ --env=\"NVIDIA_DRIVER_CAPABILITIES=all\" \\ --env=\"DISPLAY\" \\ --env=\"QT_X11_NO_MITSHM=1\" \\ --volume=\"/tmp/.X11-unix:/tmp/.X11-unix:rw\" \\ --device /dev/dri \\ <image-name> \\ bash","title":"NVIDIA"},{"location":"docker/#volume-mounting","text":"NOTE: mounted files are available only at runtime. Any files needed for building the image should be copied before then. For development we want persistent files that are shared between the host machine and the containers, files that can be changed both from the host side and from inside the container, in a setup which does not require us to rebuild the image every time we modify our code. We achieve this using volumes . To achieve the necessary permissions we create a sudo user inside the image (see \" Building the image \" section).","title":"Volume mounting"},{"location":"docker/#example-development-setup-for-a-host-with-the-os-wide-ros-install","text":"$ docker run -it \\ --volume=\"/home/<host-user>/ws\":\"/home/<container-user>/ws\":rw \\ <image-name> \\ bash We mount our host side workspace /home/<host-user>/ws to the container side workspace /home/<container-user>/ws in read-write mode. This means that the two workspaces are connected. Any change that we make in either of the two will affect both. It is best practice to build the workspace every time you start a new container and of course, every time you make a change to the code base.","title":"Example development setup for a host with the OS wide ROS install:"},{"location":"docker/#example-development-setup-for-a-host-without-the-os-wide-ros-install","text":"$ docker run -it \\ --volume=\"/home/<host-user>/ws/src\":\"/home/<container-user>/ws/src\":rw \\ <image-name> \\ bash Here we only mount the src folder of our host side workspace /home/<host-user>/ws/src to the src folder of our container side workspace /home/<container-user>/ws/src in read-write mode. This means that the two folders are connected. Any change that we make in either of the two will affect both. However, since only the src folders of the workspaces are connected, the workspace still needs to be built inside the container with catkin_make . It is best practice to build the workspace every time you start a new container and of course, every time you make a change to the code base. TODO: entrypoints, can you mount whole workspace?","title":"Example development setup for a host without the OS wide ROS install:"},{"location":"docker/#input-devices","text":"Always plug in your input devices before running the Docker container. To use input devices like joysticks inside the Docker container we have to mount them when starting the container. docker run -it \\ --device /dev/input \\ <image-name> \\ bash The above example mounts the whole input directory but you can also specify specific devices. Here we mount joystick 0. docker run -it \\ --device /dev/input/js0 \\ <image-name> \\ bash OPTIONAL: Some input devices require you to change their permissions so that they become accessible to your application (e.g. \"Configuring the Joystick\" section of this ROS tutorial). To avoid repetative changing of permissions every time you plug them in, you can create a udev rule. # with the desired input device unplugged # list the input devices on your host $ ls /dev/input by-id event0 event10 event3 event5 event7 event9 mouse0 mouse2 by-path event1 event11 event2 event4 event6 event8 mice mouse1 # plug in the desired input device # again list the input devices to see your device name $ ls /dev/input by-id event1 event20 event5 event8 mice mouse2 by-path event10 event19 event3 event6 event9 mouse0 event0 event11 event2 event4 event7 js0 mouse1 Using the above method, we find that our device name is js0 . Now we create a udev rule. Add a file /etc/udev/rules.d/99-userdev-input.rules with: KERNEL==\"js0\", SUBSYSTEM==\"input\", ACTION==\"add\", RUN+=\"/usr/bin/setfacl -m o:rw $env{DEVNAME}\" This udev rule uses ACL to set the read-write permissions of the input device js0 for the others group. You can modify the rule using ACL commands.","title":"Input devices"},{"location":"installation/","text":"Installation Dependencies ROS noetic: full desktop version is preferred. Can install other variant dependant on your use case. rosdep: command-line tool for installing system dependencies. Follow these install instructions . (optional) Docker: allows system flexibility. Viable option for no OS wide ROS install, or for working with multiple ROS versions. See Working with Docker for details. Packages overview For this setup we will be installing 3 packages: mir_robot: DFKI package containing the ROS driver and config files for MiR100 robot. mir_joy_teleop: joystick teleoperation package. mir_rest_api: MiR100 REST API. Allows direct requests or requests using a ROS service. Workspace setup We are using the source install of the mir_robot package. For other options see the package github page . # create a catkin workspace $ mkdir -p ~/MiR100/ws/src $ cd ~/MiR100/ws/src # clone mir_robot into the catkin workspace $ git clone -b noetic https://github.com/DFKI-NI/mir_robot.git # clone MiR100_robolab into the catkin workspace $ git clone -b main https://github.com/JanJericevic/MiR100_robolab.git # update and install packages $ sudo apt update \\ && sudo apt upgrade -y \\ && sudo apt install -y --no-install-recommends python3-catkin-lint python3-catkin-tools # use rosdep to install all dependencies $ cd ~/MiR100/ws/ \\ && rosdep update \\ && rosdep install --from-paths src -i -y --rosdistro noetic # build all the packages in the catkin workspace $ source /opt/ros/noetic/setup.bash \\ && cd ~/MiR100/ws/src \\ && catkin_init_workspace \\ && cd ~/MiR100/ws/ \\ && catkin_make -DCMAKE_BUILD_TYPE=RelWithDebugInfo # source the workspace and add it to the .bashrc $ source ~/MiR100/ws/devel/setup.bash \\ && echo \"source ~/MiR100/ws/devel/setup.bash\" >> ~/.bashrc NOTE: if you wish to connect to the robot on a computer with no OS wide ROS install, see the \"Working with Docker\" instructions.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#dependencies","text":"ROS noetic: full desktop version is preferred. Can install other variant dependant on your use case. rosdep: command-line tool for installing system dependencies. Follow these install instructions . (optional) Docker: allows system flexibility. Viable option for no OS wide ROS install, or for working with multiple ROS versions. See Working with Docker for details.","title":"Dependencies"},{"location":"installation/#packages-overview","text":"For this setup we will be installing 3 packages: mir_robot: DFKI package containing the ROS driver and config files for MiR100 robot. mir_joy_teleop: joystick teleoperation package. mir_rest_api: MiR100 REST API. Allows direct requests or requests using a ROS service.","title":"Packages overview"},{"location":"installation/#workspace-setup","text":"We are using the source install of the mir_robot package. For other options see the package github page . # create a catkin workspace $ mkdir -p ~/MiR100/ws/src $ cd ~/MiR100/ws/src # clone mir_robot into the catkin workspace $ git clone -b noetic https://github.com/DFKI-NI/mir_robot.git # clone MiR100_robolab into the catkin workspace $ git clone -b main https://github.com/JanJericevic/MiR100_robolab.git # update and install packages $ sudo apt update \\ && sudo apt upgrade -y \\ && sudo apt install -y --no-install-recommends python3-catkin-lint python3-catkin-tools # use rosdep to install all dependencies $ cd ~/MiR100/ws/ \\ && rosdep update \\ && rosdep install --from-paths src -i -y --rosdistro noetic # build all the packages in the catkin workspace $ source /opt/ros/noetic/setup.bash \\ && cd ~/MiR100/ws/src \\ && catkin_init_workspace \\ && cd ~/MiR100/ws/ \\ && catkin_make -DCMAKE_BUILD_TYPE=RelWithDebugInfo # source the workspace and add it to the .bashrc $ source ~/MiR100/ws/devel/setup.bash \\ && echo \"source ~/MiR100/ws/devel/setup.bash\" >> ~/.bashrc NOTE: if you wish to connect to the robot on a computer with no OS wide ROS install, see the \"Working with Docker\" instructions.","title":"Workspace setup"},{"location":"reference/","text":"MIR100 REST API This API does not contain every endpoint in the MiR100 REST API! It contains only endpoints useful to the author at the time of development. Instructions: Don't forget to set login credentials for the robot REST authorization header. Don't forget to set the robot IP if using other network than MiR100 internal hotspot. Two ways of sending REST requests handle_request(): send direct REST request to the robot API handle_request_ros(): send REST request over ROS service. Requires ROS service server node running MirRestApi MiR REST API class :param usrname: MiR interface username. Used to generate authorization header. :type usrname: str :param password: MiR interface password. Used to generate authorization header. :type password: str :param ip: robot IP, defaults to \"192.168.12.20\" :type ip: str, optional Source code in mir_rest_api/src/mir_rest_api/api.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 class MirRestApi : \"\"\"MiR REST API class :param usrname: MiR interface username. Used to generate authorization header. :type usrname: str :param password: MiR interface password. Used to generate authorization header. :type password: str :param ip: robot IP, defaults to \"192.168.12.20\" :type ip: str, optional \"\"\" def __init__ ( self , usrname : str , password : str , ip : str = \"192.168.12.20\" ) -> None : self . url = \"http://\" + ip + \"/api/v2.0.0\" self . header = { 'Content-Type' : 'application/json' , 'Authorization' : self . generate_auth_head ( usrname , password ) } # when sending requests over ROS services we need a service handle self . service_handle = rospy . ServiceProxy ( 'mir_rest_api_service' , Rest ) def generate_auth_head ( self , usrname : str , password : str ) -> str : \"\"\"generate authorization header :param usrname: MiR interface username :type usrname: str :param password: MiR interface password :type password: str :return: authorization string :rtype: str \"\"\" hashed_pass = hashlib . sha256 ( password . encode ( 'utf-8' )) . hexdigest () string = usrname + \":\" + hashed_pass string_bytes = string . encode ( \"ascii\" ) base64_bytes = base64 . b64encode ( string_bytes ) base64_string = base64_bytes . decode ( \"ascii\" ) auth_header = \"Basic \" + base64_string return auth_header def handle_request ( self ) -> List [ int , dict ]: \"\"\"Handle REST request :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" if self . method == \"GET\" : try : response = requests . get ( self . endpoint , headers = self . header ) response = [ response . status_code , response . json ()] return response except Exception as e : # rospy.logerr(e) print ( e ) elif self . method == \"DELETE\" : try : response = requests . delete ( self . endpoint , headers = self . header ) response = [ response . status_code , {}] return response except Exception as e : # rospy.logerr(e) print ( e ) elif self . method == \"POST\" : try : response = requests . post ( self . endpoint , json = self . json , headers = self . header ) response = [ response . status_code , response . json ()] if response [ 0 ] != 200 : pprint ( response [ 1 ]) return response except Exception as e : # rospy.logerr(e) print ( e ) elif self . method == \"PUT\" : try : response = requests . put ( self . endpoint , json = self . json , headers = self . header ) response = [ response . status_code , response . json ()] if response [ 0 ] != 200 : pprint ( response [ 1 ]) return response except Exception as e : # rospy.logerr(e) print ( e ) else : # rospy.loginfo(\"Incorrect REST method!\") print ( \"Incorrect REST method!\" ) def handle_request_ros ( self ) -> RestResponse : \"\"\"Handle REST request over ROS service. Needs ROS service server node running :return: ROS service response containing REST response status code and body :rtype: RestResponse \"\"\" try : response = self . service_handle ( self . method , json . dumps ( self . header ), self . endpoint , json . dumps ( self . json )) response = [ response . status_code , json . loads ( response . response )] return response except rospy . ServiceException as e : rospy . logerr ( e ) # MiR REST API endpoints: # ---------- robot state ---------- def status_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the robot status :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/status\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def status_put ( self , json : dict , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Modify the robot status :param json: request body :type json: dict :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"PUT\" self . endpoint = self . url + \"/status\" self . json = json if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def status_mode_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the current mode of the robot :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/status\" self . json = \"\" if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"mode_id\" : response [ 1 ][ \"mode_id\" ], \"mode_text\" : response [ 1 ][ \"mode_text\" ], \"mode_key_state\" : response [ 1 ][ \"mode_key_state\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"mode_id\" : response [ 1 ][ \"mode_id\" ], \"mode_text\" : response [ 1 ][ \"mode_text\" ], \"mode_key_state\" : response [ 1 ][ \"mode_key_state\" ]}] def status_state_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the current state of the robot :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/status\" self . json = \"\" if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] def status_state_id_put ( self , state_id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Modify the current state of the robot. Possible robot state_id: {3, 4, 5, 11}, State: {Ready, Pause, Executing,Manual control}. Using this method the user can only put state_id: {3, 4}, State: {Ready, Pause}. :param state_id: desired robot state :type state_id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" if state_id != 3 and state_id != 4 : print ( \"INVALID INPUT. Select state_id=3 for 'Ready' or state_id=4 for 'Pause'\" ) return self . method = \"PUT\" self . endpoint = self . url + \"/status\" self . json = { \"state_id\" : state_id } if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] def status_state_id_toggle_put ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Toggle the current state of the robot between 'Ready'/'Executing' and 'Pause'. :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" status = self . status_state_get ( ros )[ 1 ] if status [ \"state_id\" ] == 3 : state_id = 4 # rospy.loginfo(\"Setting the robot state to: 'Pause'\") print ( \"Robot is in state: 'Ready'. Setting the robot state to: 'Pause'\" ) elif status [ \"state_id\" ] == 4 : state_id = 3 # rospy.loginfo(\"Setting the robot state to: 'Ready'\") print ( \"Robot is in state: 'Pause'. Setting the robot state to: 'Ready'/'Executing'\" ) elif status [ \"state_id\" ] == 5 : state_id = 4 # rospy.loginfo(\"Setting the robot state to: 'Ready'\") print ( \"Robot is in state: 'Executing'. Setting the robot state to: 'Pause'\" ) elif status [ \"state_id\" ] == 10 : # rospy.loginfo(\"Setting the robot state to: 'Ready'\") print ( \"Robot is in state: 'EmergencyStop'. Unable to toggle robot status\" ) return else : # rospy.logerr(\"Unable to toggle robot status\") print ( \"Unable to toggle robot status\" ) return self . method = \"PUT\" self . endpoint = self . url + \"/status\" self . json = { \"state_id\" : state_id } if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] # ---------- missions ---------- def mission_groups_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of mission groups :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_groups\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_groups_group_id_missions_get ( self , group_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of missions that belong to the group with the specified group ID :param group_id: mission group ID :type group_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_groups/\" + group_id + \"/missions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of missions in the queue. Finished, failed, pending and executing missions will be displayed here :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_post ( self , mission_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Add a new mission to the mission queue. The mission will always go to the end of the queue :param mission_id: mission ID :type mission_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"POST\" self . endpoint = self . url + \"/mission_queue\" self . json = { \"mission_id\" : mission_id } if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_delete ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Abort all the pending and executing missions from the mission queue :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/mission_queue\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_id_get ( self , id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the mission with the specified ID in the mission queue :param id: mission ID in the mission queue :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue/\" + str ( id ) self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_id_delete ( self , id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Abort the mission with the specified ID in the mission queue :param id: mission ID in the mission queue :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/mission_queue/\" + str ( id ) self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_mission_queue_id_actions_get ( self , mission_queue_id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of actions from the mission with the specified ID in the mission queue :param mission_queue_id: mission ID in the mission queue :type mission_queue_id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue/\" + str ( mission_queue_id ) + \"/actions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_mission_queue_id_actions_id_get ( self , mission_queue_id : int , id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the action with the specified ID from the mission with the specified ID in the mission queue :param mission_queue_id: mission ID in the mission queue :type mission_queue_id: int :param id: action ID :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue/\" + str ( mission_queue_id ) + \"/actions/\" + str ( id ) self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of missions :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_guid_get ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the mission with the specified GUID :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_guid_delete ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Erase the mission with the specified GUID :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/missions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_guid_definition_get ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the mission with the specified GUID as an action definition that can be inserted in another mission :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + guid + \"/definition\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_mission_id_actions_get ( self , mission_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of actions that belong to the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + mission_id + \"/actions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_mission_id_actions_guid_get ( self , mission_id : str , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the action with the specified GUID that belongs to the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param guid: action GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + mission_id + \"/actions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_mission_id_actions_guid_delete ( self , mission_id : str , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Erase the action with the specified GUID from the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param guid: action GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/missions/\" + mission_id + \"/actions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () # ---------- maps---------- def maps_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of maps :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/maps\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def sessions_session_id_maps_get ( self , session_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of maps that belong to the session with the specified session ID. session_id = site_id :param session_id: site ID :type session_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/sessions/\" + session_id + \"/maps\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def maps_guid_get ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the map with the specified GUID :param guid: map GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/maps/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def maps_guid_delete ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Erase the map with the specified GUID :param guid: map GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/maps/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () # ---------- positions ---------- def maps_map_id_positions_get ( self , map_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of positions that belong to the map with the specified map ID :param map_id: map ID :type map_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/maps/\" + map_id + \"/positions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def position_transition_lists_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of position transition lists :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/position_transition_lists\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () generate_auth_head ( usrname , password ) generate authorization header :param usrname: MiR interface username :type usrname: str :param password: MiR interface password :type password: str :return: authorization string :rtype: str mir_rest_api/src/mir_rest_api/api.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def generate_auth_head ( self , usrname : str , password : str ) -> str : \"\"\"generate authorization header :param usrname: MiR interface username :type usrname: str :param password: MiR interface password :type password: str :return: authorization string :rtype: str \"\"\" hashed_pass = hashlib . sha256 ( password . encode ( 'utf-8' )) . hexdigest () string = usrname + \":\" + hashed_pass string_bytes = string . encode ( \"ascii\" ) base64_bytes = base64 . b64encode ( string_bytes ) base64_string = base64_bytes . decode ( \"ascii\" ) auth_header = \"Basic \" + base64_string return auth_header handle_request () Handle REST request :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def handle_request ( self ) -> List [ int , dict ]: \"\"\"Handle REST request :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" if self . method == \"GET\" : try : response = requests . get ( self . endpoint , headers = self . header ) response = [ response . status_code , response . json ()] return response except Exception as e : # rospy.logerr(e) print ( e ) elif self . method == \"DELETE\" : try : response = requests . delete ( self . endpoint , headers = self . header ) response = [ response . status_code , {}] return response except Exception as e : # rospy.logerr(e) print ( e ) elif self . method == \"POST\" : try : response = requests . post ( self . endpoint , json = self . json , headers = self . header ) response = [ response . status_code , response . json ()] if response [ 0 ] != 200 : pprint ( response [ 1 ]) return response except Exception as e : # rospy.logerr(e) print ( e ) elif self . method == \"PUT\" : try : response = requests . put ( self . endpoint , json = self . json , headers = self . header ) response = [ response . status_code , response . json ()] if response [ 0 ] != 200 : pprint ( response [ 1 ]) return response except Exception as e : # rospy.logerr(e) print ( e ) else : # rospy.loginfo(\"Incorrect REST method!\") print ( \"Incorrect REST method!\" ) handle_request_ros () Handle REST request over ROS service. Needs ROS service server node running :return: ROS service response containing REST response status code and body :rtype: RestResponse mir_rest_api/src/mir_rest_api/api.py 118 119 120 121 122 123 124 125 126 127 128 129 130 def handle_request_ros ( self ) -> RestResponse : \"\"\"Handle REST request over ROS service. Needs ROS service server node running :return: ROS service response containing REST response status code and body :rtype: RestResponse \"\"\" try : response = self . service_handle ( self . method , json . dumps ( self . header ), self . endpoint , json . dumps ( self . json )) response = [ response . status_code , json . loads ( response . response )] return response except rospy . ServiceException as e : rospy . logerr ( e ) maps_get ( ros = 0 ) Retrieve the list of maps :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 def maps_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of maps :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/maps\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () maps_guid_delete ( guid , ros = 0 ) Erase the map with the specified GUID :param guid: map GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 def maps_guid_delete ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Erase the map with the specified GUID :param guid: map GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/maps/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () maps_guid_get ( guid , ros = 0 ) Retrieve the details about the map with the specified GUID :param guid: map GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 def maps_guid_get ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the map with the specified GUID :param guid: map GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/maps/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () maps_map_id_positions_get ( map_id , ros = 0 ) Retrieve the list of positions that belong to the map with the specified map ID :param map_id: map ID :type map_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 def maps_map_id_positions_get ( self , map_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of positions that belong to the map with the specified map ID :param map_id: map ID :type map_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/maps/\" + map_id + \"/positions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () mission_groups_get ( ros = 0 ) Retrieve the list of mission groups :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def mission_groups_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of mission groups :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_groups\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () mission_groups_group_id_missions_get ( group_id , ros = 0 ) Retrieve the list of missions that belong to the group with the specified group ID :param group_id: mission group ID :type group_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 def mission_groups_group_id_missions_get ( self , group_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of missions that belong to the group with the specified group ID :param group_id: mission group ID :type group_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_groups/\" + group_id + \"/missions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () mission_queue_delete ( ros = 0 ) Abort all the pending and executing missions from the mission queue :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def mission_queue_delete ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Abort all the pending and executing missions from the mission queue :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/mission_queue\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () mission_queue_get ( ros = 0 ) Retrieve the list of missions in the queue. Finished, failed, pending and executing missions will be displayed here :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def mission_queue_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of missions in the queue. Finished, failed, pending and executing missions will be displayed here :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () mission_queue_id_delete ( id , ros = 0 ) Abort the mission with the specified ID in the mission queue :param id: mission ID in the mission queue :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 def mission_queue_id_delete ( self , id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Abort the mission with the specified ID in the mission queue :param id: mission ID in the mission queue :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/mission_queue/\" + str ( id ) self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () mission_queue_id_get ( id , ros = 0 ) Retrieve the details about the mission with the specified ID in the mission queue :param id: mission ID in the mission queue :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 def mission_queue_id_get ( self , id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the mission with the specified ID in the mission queue :param id: mission ID in the mission queue :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue/\" + str ( id ) self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () mission_queue_mission_queue_id_actions_get ( mission_queue_id , ros = 0 ) Retrieve the list of actions from the mission with the specified ID in the mission queue :param mission_queue_id: mission ID in the mission queue :type mission_queue_id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 def mission_queue_mission_queue_id_actions_get ( self , mission_queue_id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of actions from the mission with the specified ID in the mission queue :param mission_queue_id: mission ID in the mission queue :type mission_queue_id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue/\" + str ( mission_queue_id ) + \"/actions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () mission_queue_mission_queue_id_actions_id_get ( mission_queue_id , id , ros = 0 ) Retrieve the details about the action with the specified ID from the mission with the specified ID in the mission queue :param mission_queue_id: mission ID in the mission queue :type mission_queue_id: int :param id: action ID :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def mission_queue_mission_queue_id_actions_id_get ( self , mission_queue_id : int , id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the action with the specified ID from the mission with the specified ID in the mission queue :param mission_queue_id: mission ID in the mission queue :type mission_queue_id: int :param id: action ID :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue/\" + str ( mission_queue_id ) + \"/actions/\" + str ( id ) self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () mission_queue_post ( mission_id , ros = 0 ) Add a new mission to the mission queue. The mission will always go to the end of the queue :param mission_id: mission ID :type mission_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def mission_queue_post ( self , mission_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Add a new mission to the mission queue. The mission will always go to the end of the queue :param mission_id: mission ID :type mission_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"POST\" self . endpoint = self . url + \"/mission_queue\" self . json = { \"mission_id\" : mission_id } if ros == 1 : return self . handle_request_ros () else : return self . handle_request () missions_get ( ros = 0 ) Retrieve the list of missions :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def missions_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of missions :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () missions_guid_definition_get ( guid , ros = 0 ) Retrieve the mission with the specified GUID as an action definition that can be inserted in another mission :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 def missions_guid_definition_get ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the mission with the specified GUID as an action definition that can be inserted in another mission :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + guid + \"/definition\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () missions_guid_delete ( guid , ros = 0 ) Erase the mission with the specified GUID :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 def missions_guid_delete ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Erase the mission with the specified GUID :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/missions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () missions_guid_get ( guid , ros = 0 ) Retrieve the details about the mission with the specified GUID :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 def missions_guid_get ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the mission with the specified GUID :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () missions_mission_id_actions_get ( mission_id , ros = 0 ) Retrieve the list of actions that belong to the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def missions_mission_id_actions_get ( self , mission_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of actions that belong to the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + mission_id + \"/actions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () missions_mission_id_actions_guid_delete ( mission_id , guid , ros = 0 ) Erase the action with the specified GUID from the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param guid: action GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 def missions_mission_id_actions_guid_delete ( self , mission_id : str , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Erase the action with the specified GUID from the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param guid: action GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/missions/\" + mission_id + \"/actions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () missions_mission_id_actions_guid_get ( mission_id , guid , ros = 0 ) Retrieve the details about the action with the specified GUID that belongs to the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param guid: action GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 def missions_mission_id_actions_guid_get ( self , mission_id : str , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the action with the specified GUID that belongs to the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param guid: action GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + mission_id + \"/actions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () position_transition_lists_get ( ros = 0 ) Retrieve the list of position transition lists :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 def position_transition_lists_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of position transition lists :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/position_transition_lists\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () sessions_session_id_maps_get ( session_id , ros = 0 ) Retrieve the list of maps that belong to the session with the specified session ID. session_id = site_id :param session_id: site ID :type session_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 def sessions_session_id_maps_get ( self , session_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of maps that belong to the session with the specified session ID. session_id = site_id :param session_id: site ID :type session_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/sessions/\" + session_id + \"/maps\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () status_get ( ros = 0 ) Retrieve the robot status :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def status_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the robot status :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/status\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () status_mode_get ( ros = 0 ) Retrieve the current mode of the robot :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def status_mode_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the current mode of the robot :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/status\" self . json = \"\" if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"mode_id\" : response [ 1 ][ \"mode_id\" ], \"mode_text\" : response [ 1 ][ \"mode_text\" ], \"mode_key_state\" : response [ 1 ][ \"mode_key_state\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"mode_id\" : response [ 1 ][ \"mode_id\" ], \"mode_text\" : response [ 1 ][ \"mode_text\" ], \"mode_key_state\" : response [ 1 ][ \"mode_key_state\" ]}] status_put ( json , ros = 0 ) Modify the robot status :param json: request body :type json: dict :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def status_put ( self , json : dict , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Modify the robot status :param json: request body :type json: dict :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"PUT\" self . endpoint = self . url + \"/status\" self . json = json if ros == 1 : return self . handle_request_ros () else : return self . handle_request () status_state_get ( ros = 0 ) Retrieve the current state of the robot :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def status_state_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the current state of the robot :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/status\" self . json = \"\" if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] status_state_id_put ( state_id , ros = 0 ) Modify the current state of the robot. Possible robot state_id: {3, 4, 5, 11}, State: {Ready, Pause, Executing,Manual control}. Using this method the user can only put state_id: {3, 4}, State: {Ready, Pause}. :param state_id: desired robot state :type state_id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def status_state_id_put ( self , state_id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Modify the current state of the robot. Possible robot state_id: {3, 4, 5, 11}, State: {Ready, Pause, Executing,Manual control}. Using this method the user can only put state_id: {3, 4}, State: {Ready, Pause}. :param state_id: desired robot state :type state_id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" if state_id != 3 and state_id != 4 : print ( \"INVALID INPUT. Select state_id=3 for 'Ready' or state_id=4 for 'Pause'\" ) return self . method = \"PUT\" self . endpoint = self . url + \"/status\" self . json = { \"state_id\" : state_id } if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] status_state_id_toggle_put ( ros = 0 ) Toggle the current state of the robot between 'Ready'/'Executing' and 'Pause'. :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def status_state_id_toggle_put ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Toggle the current state of the robot between 'Ready'/'Executing' and 'Pause'. :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" status = self . status_state_get ( ros )[ 1 ] if status [ \"state_id\" ] == 3 : state_id = 4 # rospy.loginfo(\"Setting the robot state to: 'Pause'\") print ( \"Robot is in state: 'Ready'. Setting the robot state to: 'Pause'\" ) elif status [ \"state_id\" ] == 4 : state_id = 3 # rospy.loginfo(\"Setting the robot state to: 'Ready'\") print ( \"Robot is in state: 'Pause'. Setting the robot state to: 'Ready'/'Executing'\" ) elif status [ \"state_id\" ] == 5 : state_id = 4 # rospy.loginfo(\"Setting the robot state to: 'Ready'\") print ( \"Robot is in state: 'Executing'. Setting the robot state to: 'Pause'\" ) elif status [ \"state_id\" ] == 10 : # rospy.loginfo(\"Setting the robot state to: 'Ready'\") print ( \"Robot is in state: 'EmergencyStop'. Unable to toggle robot status\" ) return else : # rospy.logerr(\"Unable to toggle robot status\") print ( \"Unable to toggle robot status\" ) return self . method = \"PUT\" self . endpoint = self . url + \"/status\" self . json = { \"state_id\" : state_id } if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}]","title":"Reference"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi","text":"MiR REST API class :param usrname: MiR interface username. Used to generate authorization header. :type usrname: str :param password: MiR interface password. Used to generate authorization header. :type password: str :param ip: robot IP, defaults to \"192.168.12.20\" :type ip: str, optional Source code in mir_rest_api/src/mir_rest_api/api.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 class MirRestApi : \"\"\"MiR REST API class :param usrname: MiR interface username. Used to generate authorization header. :type usrname: str :param password: MiR interface password. Used to generate authorization header. :type password: str :param ip: robot IP, defaults to \"192.168.12.20\" :type ip: str, optional \"\"\" def __init__ ( self , usrname : str , password : str , ip : str = \"192.168.12.20\" ) -> None : self . url = \"http://\" + ip + \"/api/v2.0.0\" self . header = { 'Content-Type' : 'application/json' , 'Authorization' : self . generate_auth_head ( usrname , password ) } # when sending requests over ROS services we need a service handle self . service_handle = rospy . ServiceProxy ( 'mir_rest_api_service' , Rest ) def generate_auth_head ( self , usrname : str , password : str ) -> str : \"\"\"generate authorization header :param usrname: MiR interface username :type usrname: str :param password: MiR interface password :type password: str :return: authorization string :rtype: str \"\"\" hashed_pass = hashlib . sha256 ( password . encode ( 'utf-8' )) . hexdigest () string = usrname + \":\" + hashed_pass string_bytes = string . encode ( \"ascii\" ) base64_bytes = base64 . b64encode ( string_bytes ) base64_string = base64_bytes . decode ( \"ascii\" ) auth_header = \"Basic \" + base64_string return auth_header def handle_request ( self ) -> List [ int , dict ]: \"\"\"Handle REST request :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" if self . method == \"GET\" : try : response = requests . get ( self . endpoint , headers = self . header ) response = [ response . status_code , response . json ()] return response except Exception as e : # rospy.logerr(e) print ( e ) elif self . method == \"DELETE\" : try : response = requests . delete ( self . endpoint , headers = self . header ) response = [ response . status_code , {}] return response except Exception as e : # rospy.logerr(e) print ( e ) elif self . method == \"POST\" : try : response = requests . post ( self . endpoint , json = self . json , headers = self . header ) response = [ response . status_code , response . json ()] if response [ 0 ] != 200 : pprint ( response [ 1 ]) return response except Exception as e : # rospy.logerr(e) print ( e ) elif self . method == \"PUT\" : try : response = requests . put ( self . endpoint , json = self . json , headers = self . header ) response = [ response . status_code , response . json ()] if response [ 0 ] != 200 : pprint ( response [ 1 ]) return response except Exception as e : # rospy.logerr(e) print ( e ) else : # rospy.loginfo(\"Incorrect REST method!\") print ( \"Incorrect REST method!\" ) def handle_request_ros ( self ) -> RestResponse : \"\"\"Handle REST request over ROS service. Needs ROS service server node running :return: ROS service response containing REST response status code and body :rtype: RestResponse \"\"\" try : response = self . service_handle ( self . method , json . dumps ( self . header ), self . endpoint , json . dumps ( self . json )) response = [ response . status_code , json . loads ( response . response )] return response except rospy . ServiceException as e : rospy . logerr ( e ) # MiR REST API endpoints: # ---------- robot state ---------- def status_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the robot status :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/status\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def status_put ( self , json : dict , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Modify the robot status :param json: request body :type json: dict :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"PUT\" self . endpoint = self . url + \"/status\" self . json = json if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def status_mode_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the current mode of the robot :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/status\" self . json = \"\" if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"mode_id\" : response [ 1 ][ \"mode_id\" ], \"mode_text\" : response [ 1 ][ \"mode_text\" ], \"mode_key_state\" : response [ 1 ][ \"mode_key_state\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"mode_id\" : response [ 1 ][ \"mode_id\" ], \"mode_text\" : response [ 1 ][ \"mode_text\" ], \"mode_key_state\" : response [ 1 ][ \"mode_key_state\" ]}] def status_state_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the current state of the robot :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/status\" self . json = \"\" if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] def status_state_id_put ( self , state_id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Modify the current state of the robot. Possible robot state_id: {3, 4, 5, 11}, State: {Ready, Pause, Executing,Manual control}. Using this method the user can only put state_id: {3, 4}, State: {Ready, Pause}. :param state_id: desired robot state :type state_id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" if state_id != 3 and state_id != 4 : print ( \"INVALID INPUT. Select state_id=3 for 'Ready' or state_id=4 for 'Pause'\" ) return self . method = \"PUT\" self . endpoint = self . url + \"/status\" self . json = { \"state_id\" : state_id } if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] def status_state_id_toggle_put ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Toggle the current state of the robot between 'Ready'/'Executing' and 'Pause'. :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" status = self . status_state_get ( ros )[ 1 ] if status [ \"state_id\" ] == 3 : state_id = 4 # rospy.loginfo(\"Setting the robot state to: 'Pause'\") print ( \"Robot is in state: 'Ready'. Setting the robot state to: 'Pause'\" ) elif status [ \"state_id\" ] == 4 : state_id = 3 # rospy.loginfo(\"Setting the robot state to: 'Ready'\") print ( \"Robot is in state: 'Pause'. Setting the robot state to: 'Ready'/'Executing'\" ) elif status [ \"state_id\" ] == 5 : state_id = 4 # rospy.loginfo(\"Setting the robot state to: 'Ready'\") print ( \"Robot is in state: 'Executing'. Setting the robot state to: 'Pause'\" ) elif status [ \"state_id\" ] == 10 : # rospy.loginfo(\"Setting the robot state to: 'Ready'\") print ( \"Robot is in state: 'EmergencyStop'. Unable to toggle robot status\" ) return else : # rospy.logerr(\"Unable to toggle robot status\") print ( \"Unable to toggle robot status\" ) return self . method = \"PUT\" self . endpoint = self . url + \"/status\" self . json = { \"state_id\" : state_id } if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] # ---------- missions ---------- def mission_groups_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of mission groups :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_groups\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_groups_group_id_missions_get ( self , group_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of missions that belong to the group with the specified group ID :param group_id: mission group ID :type group_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_groups/\" + group_id + \"/missions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of missions in the queue. Finished, failed, pending and executing missions will be displayed here :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_post ( self , mission_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Add a new mission to the mission queue. The mission will always go to the end of the queue :param mission_id: mission ID :type mission_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"POST\" self . endpoint = self . url + \"/mission_queue\" self . json = { \"mission_id\" : mission_id } if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_delete ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Abort all the pending and executing missions from the mission queue :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/mission_queue\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_id_get ( self , id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the mission with the specified ID in the mission queue :param id: mission ID in the mission queue :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue/\" + str ( id ) self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_id_delete ( self , id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Abort the mission with the specified ID in the mission queue :param id: mission ID in the mission queue :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/mission_queue/\" + str ( id ) self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_mission_queue_id_actions_get ( self , mission_queue_id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of actions from the mission with the specified ID in the mission queue :param mission_queue_id: mission ID in the mission queue :type mission_queue_id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue/\" + str ( mission_queue_id ) + \"/actions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def mission_queue_mission_queue_id_actions_id_get ( self , mission_queue_id : int , id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the action with the specified ID from the mission with the specified ID in the mission queue :param mission_queue_id: mission ID in the mission queue :type mission_queue_id: int :param id: action ID :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue/\" + str ( mission_queue_id ) + \"/actions/\" + str ( id ) self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of missions :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_guid_get ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the mission with the specified GUID :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_guid_delete ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Erase the mission with the specified GUID :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/missions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_guid_definition_get ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the mission with the specified GUID as an action definition that can be inserted in another mission :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + guid + \"/definition\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_mission_id_actions_get ( self , mission_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of actions that belong to the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + mission_id + \"/actions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_mission_id_actions_guid_get ( self , mission_id : str , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the action with the specified GUID that belongs to the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param guid: action GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + mission_id + \"/actions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def missions_mission_id_actions_guid_delete ( self , mission_id : str , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Erase the action with the specified GUID from the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param guid: action GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/missions/\" + mission_id + \"/actions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () # ---------- maps---------- def maps_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of maps :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/maps\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def sessions_session_id_maps_get ( self , session_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of maps that belong to the session with the specified session ID. session_id = site_id :param session_id: site ID :type session_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/sessions/\" + session_id + \"/maps\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def maps_guid_get ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the map with the specified GUID :param guid: map GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/maps/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def maps_guid_delete ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Erase the map with the specified GUID :param guid: map GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/maps/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () # ---------- positions ---------- def maps_map_id_positions_get ( self , map_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of positions that belong to the map with the specified map ID :param map_id: map ID :type map_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/maps/\" + map_id + \"/positions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request () def position_transition_lists_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of position transition lists :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/position_transition_lists\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"MirRestApi"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.generate_auth_head","text":"generate authorization header :param usrname: MiR interface username :type usrname: str :param password: MiR interface password :type password: str :return: authorization string :rtype: str mir_rest_api/src/mir_rest_api/api.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def generate_auth_head ( self , usrname : str , password : str ) -> str : \"\"\"generate authorization header :param usrname: MiR interface username :type usrname: str :param password: MiR interface password :type password: str :return: authorization string :rtype: str \"\"\" hashed_pass = hashlib . sha256 ( password . encode ( 'utf-8' )) . hexdigest () string = usrname + \":\" + hashed_pass string_bytes = string . encode ( \"ascii\" ) base64_bytes = base64 . b64encode ( string_bytes ) base64_string = base64_bytes . decode ( \"ascii\" ) auth_header = \"Basic \" + base64_string return auth_header","title":"generate_auth_head()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.handle_request","text":"Handle REST request :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def handle_request ( self ) -> List [ int , dict ]: \"\"\"Handle REST request :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" if self . method == \"GET\" : try : response = requests . get ( self . endpoint , headers = self . header ) response = [ response . status_code , response . json ()] return response except Exception as e : # rospy.logerr(e) print ( e ) elif self . method == \"DELETE\" : try : response = requests . delete ( self . endpoint , headers = self . header ) response = [ response . status_code , {}] return response except Exception as e : # rospy.logerr(e) print ( e ) elif self . method == \"POST\" : try : response = requests . post ( self . endpoint , json = self . json , headers = self . header ) response = [ response . status_code , response . json ()] if response [ 0 ] != 200 : pprint ( response [ 1 ]) return response except Exception as e : # rospy.logerr(e) print ( e ) elif self . method == \"PUT\" : try : response = requests . put ( self . endpoint , json = self . json , headers = self . header ) response = [ response . status_code , response . json ()] if response [ 0 ] != 200 : pprint ( response [ 1 ]) return response except Exception as e : # rospy.logerr(e) print ( e ) else : # rospy.loginfo(\"Incorrect REST method!\") print ( \"Incorrect REST method!\" )","title":"handle_request()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.handle_request_ros","text":"Handle REST request over ROS service. Needs ROS service server node running :return: ROS service response containing REST response status code and body :rtype: RestResponse mir_rest_api/src/mir_rest_api/api.py 118 119 120 121 122 123 124 125 126 127 128 129 130 def handle_request_ros ( self ) -> RestResponse : \"\"\"Handle REST request over ROS service. Needs ROS service server node running :return: ROS service response containing REST response status code and body :rtype: RestResponse \"\"\" try : response = self . service_handle ( self . method , json . dumps ( self . header ), self . endpoint , json . dumps ( self . json )) response = [ response . status_code , json . loads ( response . response )] return response except rospy . ServiceException as e : rospy . logerr ( e )","title":"handle_request_ros()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.maps_get","text":"Retrieve the list of maps :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 def maps_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of maps :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/maps\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"maps_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.maps_guid_delete","text":"Erase the map with the specified GUID :param guid: map GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 def maps_guid_delete ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Erase the map with the specified GUID :param guid: map GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/maps/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"maps_guid_delete()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.maps_guid_get","text":"Retrieve the details about the map with the specified GUID :param guid: map GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 def maps_guid_get ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the map with the specified GUID :param guid: map GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/maps/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"maps_guid_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.maps_map_id_positions_get","text":"Retrieve the list of positions that belong to the map with the specified map ID :param map_id: map ID :type map_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 def maps_map_id_positions_get ( self , map_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of positions that belong to the map with the specified map ID :param map_id: map ID :type map_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/maps/\" + map_id + \"/positions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"maps_map_id_positions_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.mission_groups_get","text":"Retrieve the list of mission groups :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def mission_groups_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of mission groups :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_groups\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"mission_groups_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.mission_groups_group_id_missions_get","text":"Retrieve the list of missions that belong to the group with the specified group ID :param group_id: mission group ID :type group_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 def mission_groups_group_id_missions_get ( self , group_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of missions that belong to the group with the specified group ID :param group_id: mission group ID :type group_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_groups/\" + group_id + \"/missions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"mission_groups_group_id_missions_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.mission_queue_delete","text":"Abort all the pending and executing missions from the mission queue :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def mission_queue_delete ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Abort all the pending and executing missions from the mission queue :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/mission_queue\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"mission_queue_delete()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.mission_queue_get","text":"Retrieve the list of missions in the queue. Finished, failed, pending and executing missions will be displayed here :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 def mission_queue_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of missions in the queue. Finished, failed, pending and executing missions will be displayed here :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"mission_queue_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.mission_queue_id_delete","text":"Abort the mission with the specified ID in the mission queue :param id: mission ID in the mission queue :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 def mission_queue_id_delete ( self , id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Abort the mission with the specified ID in the mission queue :param id: mission ID in the mission queue :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/mission_queue/\" + str ( id ) self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"mission_queue_id_delete()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.mission_queue_id_get","text":"Retrieve the details about the mission with the specified ID in the mission queue :param id: mission ID in the mission queue :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 def mission_queue_id_get ( self , id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the mission with the specified ID in the mission queue :param id: mission ID in the mission queue :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue/\" + str ( id ) self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"mission_queue_id_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.mission_queue_mission_queue_id_actions_get","text":"Retrieve the list of actions from the mission with the specified ID in the mission queue :param mission_queue_id: mission ID in the mission queue :type mission_queue_id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 def mission_queue_mission_queue_id_actions_get ( self , mission_queue_id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of actions from the mission with the specified ID in the mission queue :param mission_queue_id: mission ID in the mission queue :type mission_queue_id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue/\" + str ( mission_queue_id ) + \"/actions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"mission_queue_mission_queue_id_actions_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.mission_queue_mission_queue_id_actions_id_get","text":"Retrieve the details about the action with the specified ID from the mission with the specified ID in the mission queue :param mission_queue_id: mission ID in the mission queue :type mission_queue_id: int :param id: action ID :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def mission_queue_mission_queue_id_actions_id_get ( self , mission_queue_id : int , id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the action with the specified ID from the mission with the specified ID in the mission queue :param mission_queue_id: mission ID in the mission queue :type mission_queue_id: int :param id: action ID :type id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/mission_queue/\" + str ( mission_queue_id ) + \"/actions/\" + str ( id ) self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"mission_queue_mission_queue_id_actions_id_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.mission_queue_post","text":"Add a new mission to the mission queue. The mission will always go to the end of the queue :param mission_id: mission ID :type mission_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def mission_queue_post ( self , mission_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Add a new mission to the mission queue. The mission will always go to the end of the queue :param mission_id: mission ID :type mission_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"POST\" self . endpoint = self . url + \"/mission_queue\" self . json = { \"mission_id\" : mission_id } if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"mission_queue_post()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.missions_get","text":"Retrieve the list of missions :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def missions_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of missions :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"missions_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.missions_guid_definition_get","text":"Retrieve the mission with the specified GUID as an action definition that can be inserted in another mission :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 def missions_guid_definition_get ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the mission with the specified GUID as an action definition that can be inserted in another mission :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + guid + \"/definition\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"missions_guid_definition_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.missions_guid_delete","text":"Erase the mission with the specified GUID :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 def missions_guid_delete ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Erase the mission with the specified GUID :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/missions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"missions_guid_delete()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.missions_guid_get","text":"Retrieve the details about the mission with the specified GUID :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 def missions_guid_get ( self , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the mission with the specified GUID :param guid: mission GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"missions_guid_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.missions_mission_id_actions_get","text":"Retrieve the list of actions that belong to the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def missions_mission_id_actions_get ( self , mission_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of actions that belong to the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + mission_id + \"/actions\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"missions_mission_id_actions_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.missions_mission_id_actions_guid_delete","text":"Erase the action with the specified GUID from the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param guid: action GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 def missions_mission_id_actions_guid_delete ( self , mission_id : str , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Erase the action with the specified GUID from the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param guid: action GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"DELETE\" self . endpoint = self . url + \"/missions/\" + mission_id + \"/actions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"missions_mission_id_actions_guid_delete()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.missions_mission_id_actions_guid_get","text":"Retrieve the details about the action with the specified GUID that belongs to the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param guid: action GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 def missions_mission_id_actions_guid_get ( self , mission_id : str , guid : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the details about the action with the specified GUID that belongs to the mission with the specified mission ID :param mission_id: mission ID :type mission_id: str :param guid: action GUID :type guid: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/missions/\" + mission_id + \"/actions/\" + guid self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"missions_mission_id_actions_guid_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.position_transition_lists_get","text":"Retrieve the list of position transition lists :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 def position_transition_lists_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of position transition lists :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/position_transition_lists\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"position_transition_lists_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.sessions_session_id_maps_get","text":"Retrieve the list of maps that belong to the session with the specified session ID. session_id = site_id :param session_id: site ID :type session_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 def sessions_session_id_maps_get ( self , session_id : str , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the list of maps that belong to the session with the specified session ID. session_id = site_id :param session_id: site ID :type session_id: str :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/sessions/\" + session_id + \"/maps\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"sessions_session_id_maps_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.status_get","text":"Retrieve the robot status :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def status_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the robot status :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/status\" self . json = \"\" if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"status_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.status_mode_get","text":"Retrieve the current mode of the robot :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def status_mode_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the current mode of the robot :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/status\" self . json = \"\" if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"mode_id\" : response [ 1 ][ \"mode_id\" ], \"mode_text\" : response [ 1 ][ \"mode_text\" ], \"mode_key_state\" : response [ 1 ][ \"mode_key_state\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"mode_id\" : response [ 1 ][ \"mode_id\" ], \"mode_text\" : response [ 1 ][ \"mode_text\" ], \"mode_key_state\" : response [ 1 ][ \"mode_key_state\" ]}]","title":"status_mode_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.status_put","text":"Modify the robot status :param json: request body :type json: dict :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def status_put ( self , json : dict , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Modify the robot status :param json: request body :type json: dict :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"PUT\" self . endpoint = self . url + \"/status\" self . json = json if ros == 1 : return self . handle_request_ros () else : return self . handle_request ()","title":"status_put()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.status_state_get","text":"Retrieve the current state of the robot :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def status_state_get ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Retrieve the current state of the robot :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" self . method = \"GET\" self . endpoint = self . url + \"/status\" self . json = \"\" if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}]","title":"status_state_get()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.status_state_id_put","text":"Modify the current state of the robot. Possible robot state_id: {3, 4, 5, 11}, State: {Ready, Pause, Executing,Manual control}. Using this method the user can only put state_id: {3, 4}, State: {Ready, Pause}. :param state_id: desired robot state :type state_id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def status_state_id_put ( self , state_id : int , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Modify the current state of the robot. Possible robot state_id: {3, 4, 5, 11}, State: {Ready, Pause, Executing,Manual control}. Using this method the user can only put state_id: {3, 4}, State: {Ready, Pause}. :param state_id: desired robot state :type state_id: int :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" if state_id != 3 and state_id != 4 : print ( \"INVALID INPUT. Select state_id=3 for 'Ready' or state_id=4 for 'Pause'\" ) return self . method = \"PUT\" self . endpoint = self . url + \"/status\" self . json = { \"state_id\" : state_id } if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}]","title":"status_state_id_put()"},{"location":"reference/#mir_rest_api.src.mir_rest_api.api.MirRestApi.status_state_id_toggle_put","text":"Toggle the current state of the robot between 'Ready'/'Executing' and 'Pause'. :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] mir_rest_api/src/mir_rest_api/api.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def status_state_id_toggle_put ( self , ros : bool = 0 ) -> List [ int , dict ]: \"\"\"Toggle the current state of the robot between 'Ready'/'Executing' and 'Pause'. :param ros: use ROS service, defaults to 0 :type ros: bool, optional :return: a list containing REST response status code and body :rtype: list[int, dict] \"\"\" status = self . status_state_get ( ros )[ 1 ] if status [ \"state_id\" ] == 3 : state_id = 4 # rospy.loginfo(\"Setting the robot state to: 'Pause'\") print ( \"Robot is in state: 'Ready'. Setting the robot state to: 'Pause'\" ) elif status [ \"state_id\" ] == 4 : state_id = 3 # rospy.loginfo(\"Setting the robot state to: 'Ready'\") print ( \"Robot is in state: 'Pause'. Setting the robot state to: 'Ready'/'Executing'\" ) elif status [ \"state_id\" ] == 5 : state_id = 4 # rospy.loginfo(\"Setting the robot state to: 'Ready'\") print ( \"Robot is in state: 'Executing'. Setting the robot state to: 'Pause'\" ) elif status [ \"state_id\" ] == 10 : # rospy.loginfo(\"Setting the robot state to: 'Ready'\") print ( \"Robot is in state: 'EmergencyStop'. Unable to toggle robot status\" ) return else : # rospy.logerr(\"Unable to toggle robot status\") print ( \"Unable to toggle robot status\" ) return self . method = \"PUT\" self . endpoint = self . url + \"/status\" self . json = { \"state_id\" : state_id } if ros == 1 : response = self . handle_request_ros () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}] else : response = self . handle_request () return [ response [ 0 ], { \"state_id\" : response [ 1 ][ \"state_id\" ], \"state_text\" : response [ 1 ][ \"state_text\" ]}]","title":"status_state_id_toggle_put()"}]}